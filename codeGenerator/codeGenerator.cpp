#include "codeGenerator.h"
using namespace std;

int CodeGenerator::state_machine_code(int ** states_functions, int number_of_states){

	CodeGenerator code_gen;

	//Opens the file
	ofstream code_file;
	string code;
	code_file.open(code_file_name, ios_base::app);

	//Initializes a state machine var
	code = "//State Machine state\n";
	code += "int state = 0;\n\n";

	//Opens the state machine
	code += "switch(state){\n";

	//writes to the file
	code_file << code;

	//You need to close the file before call a function that opens it
	code_file.close();

	//For each state, calls the linear_function to write it's respective functions
	for(int i = 0; i < number_of_states; i++){

		code_file.open(code_file_name, ios_base::app);

		//Another state
		code = "\n	case '" + to_string(i) + "':\n";

		//writes to the file
		code_file << code;

		//You need to close the file before call a function that opens it
		code_file.close();

		//Write the linear code state
		code_gen.linear_function(states_functions[i]);
	}

	//Opens the file
	code_file.open(code_file_name, ios_base::app);

	//Close the switch
	code = "\n    }\n";

	//writes to the file
	code_file << code;
	//You need to close the file before call a function that opens it
	code_file.close();

	return 0;
}

int CodeGenerator::start(int *id_modules){

	//Starts the generated code file
	ofstream code_file;
	string code;
	FILE * data_base;
	string s_modules;
	string input_modules = "";

	code_file.open(code_file_name);

	code = "//This code was generated by codeGenerator\n";
	//Fist, all the includes should be put here
	code = code + "#include<iostream>\n";

	//Writes to file
	code_file << code;
	code_file.close();

	//Writes the modules chosen by the user
	int i = 0;
	data_base = fopen(modules_data_base_path.c_str(), "rb");
	if(data_base != 0){
       while(id_modules[i] != -1){
			fseek(data_base, (id_modules[i]-1)*sizeof(code_generator_struct), SEEK_SET);
			fread(&data_for_modules, sizeof(code_generator_struct), 1, data_base);
            s_modules = data_for_modules.name;
			input_modules = input_modules + "\n";
			input_modules = input_modules + "#include<" +s_modules + ".h>";
            s_modules = "";
					i++;
			}
		fclose(data_base);
        cout << input_modules << endl;
        code_file.open(code_file_name, ios_base::app);
        code_file << input_modules + "\n\n";
        code_file.close();
    }
	else{
		cout << "Error - Modules data base cannot be opened." << endl;
			return -1;
	}

	code_file.open(code_file_name, ios_base::app);

	//Namespace std, default in c++ applications
	code = "using namespace std;\n\n";
	//Starts the main function
	code = code + "int main(){\n";
	//Code....

	//Writes to file
	code_file << code;
	code_file.close();
}

void CodeGenerator::finish(){

	//Starts the generated code file
	ofstream code_file;
	string code;

	//Open the file to append
	code_file.open(code_file_name, ios_base::app);

	//Writes the main return and closes the code
	code = "\n";
	code = code + "	return 0;\n";
	code = code + "}";

	//Writes to file
	code_file << code;
	code_file.close();
}

void CodeGenerator::create_functions_database(){

    CodeGenerator code_gen;
    code_generator_struct new_m; //Struct that receives new function data
    FILE *data_base; //Pointer to data_base file
    cout << "    Put function ID: ";
    cin >> new_m.id;
    cin.ignore();//Ignores upper cin \n
    cout << endl << "    Put function name: ";
    cin.getline(new_m.name, 100);

    //Verify the input name
    while(check_function_name(new_m.name) != 0){
    	cout << endl << "    Put function name: ";
    	cin.getline(new_m.name, 100);
    }

    cout << endl << "	Put the number of parameters: ";
    cin >> new_m.number_of_parameters;
    cin.ignore();

    //Insert all the parameters
    for(int i = 0; i < new_m.number_of_parameters; i++){
    	cout <<  endl << "	  Put type of the parameter: ";
	    cin.getline(new_m.param_types[i], 100);

	    cout << endl << "	Put the name of the parameter: ";
	    cin.getline(new_m.param_names[i], 100);
    }

    data_base = fopen(functions_data_base_path.c_str(), "r+b");
    fseek(data_base, (new_m.id-1)*sizeof(code_generator_struct), SEEK_SET);
    fwrite(&new_m, sizeof(code_generator_struct), 1, data_base);
    fclose(data_base);
}

int CodeGenerator::check_function_name(char* name){

	for(int i = 0; i < sizeof(name); i++){
		if(name[i] == '(' || name[i] == ')'){
			cout << "\nInvalid characters: ( or )" << endl;
			return 1;
		}
		if(name[i] == ';'){
			cout << "\nInvalid character: ;" << endl;
			return 1;
		}
		if(name[i] == ' ' && i < sizeof(name)-1){
			cout << "\nInvalid character: space in the name" << endl;
			return 1;
		}
 	}

 	return 0;

}


void CodeGenerator::create_modules_database(){
   
    code_generator_struct new_f; //Struct that receives new function data
    FILE *data_base; //Pointer to data_base file

    cout << "    Put module ID: ";
    cin >> new_f.id;
    cin.ignore();//Ignores upper cin \n
    cout << endl << "    Put module name: ";
    cin.getline(new_f.name, 100);

    //Verify the input name
    while(check_module_name(new_f.name) != 0){
    	cout << endl << "    Put module name: ";
    	cin >> new_f.name;
    }

    data_base = fopen(modules_data_base_path.c_str(), "r+b");
    fseek(data_base, (new_f.id-1)*sizeof(code_generator_struct), SEEK_SET);
    fwrite(&new_f, sizeof(code_generator_struct), 1, data_base);
    fclose(data_base);
}

int CodeGenerator::check_module_name(char* name){

	for(int i = 0; i < sizeof(name); i++){
		if(name[i] == '<' || name[i] == '>'){
			cout << "\nInvalid characters: < or >." << endl;
			return 1;
		}
		if(i < sizeof(name)-1 && name[i] == '.' && name[i+1] == 'h'){
			cout << "\nInvalid characters: .h" << endl;
			return 1;
		}
		if(name[i] == ' ' && i < sizeof(name)-1){
			cout << "\nInvalid characters: space in the name" << endl;
			return 1;
		}
 	}

 	return 0;

}

int CodeGenerator::linear_function(int id_functions[]){

	FILE * data_base;
    ofstream code_file;
    string s_functions;
	string linear_functions = "";
	int i = 0;

	data_base = fopen(functions_data_base_path.c_str(), "rb");
	if(data_base != 0){
       while(id_functions[i] != -1){
			fseek(data_base, (id_functions[i]-1)*sizeof(code_generator_struct), SEEK_SET);
			fread(&data_for_functions, sizeof(code_generator_struct), 1, data_base);
            s_functions = data_for_functions.name;
			linear_functions = linear_functions + "\n    ";

			//Write the variables according to the parameters names and types
			//Write parameters
			for(int j = 0; j < data_for_functions.number_of_parameters; j++){
				//Type
				linear_functions =  linear_functions + data_for_functions.param_types[j] + " ";
				//Name
				linear_functions = linear_functions + data_for_functions.param_names[j] + "\n    ";
			}


			linear_functions = linear_functions + s_functions + "(";
			
			//Write parameters
			for(int j = 0; j < data_for_functions.number_of_parameters; j++){
				//Name
				linear_functions = linear_functions + data_for_functions.param_names[j];

				if(j == data_for_functions.number_of_parameters - 1){
					linear_functions = linear_functions + ");\n";
				}
				else{
					linear_functions = linear_functions + ", ";
				}
			}

            s_functions = "";
					i++;
			}
		fclose(data_base);
        cout << linear_functions << endl;
        code_file.open(code_file_name, ios_base::app);
        code_file << linear_functions;
        code_file.close();
    }
	else{
		cout << "Error - Functions data base cannot be opened." << endl;
			return -1;
	}
	return 0;
}

void CodeGenerator::initial_setup(){

	//Starts the generated code file
	ofstream code_file;
	string code;

	//Open the file to append
	code_file.open(code_file_name, ios_base::app);

	code = "\n";
	code = code + "	//Code for the initial setup\n";
	code = code + "	system_init();\n";
	code = code + "	system_config();\n";
	code = code + "\n";

	//Writes to file
	code_file << code;
	code_file.close();
}

//Initializes the state machine counter
int CodeGenerator::curr_state_number = 0;
